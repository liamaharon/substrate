<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`ark-serialize` defines the `CanonicalSerialize` and `CanonicalDeserialize` traits for serializing and deserializing Rust data structures to bytes efficiently. The interfaces offered by these traits are specialized for serializing cryptographic objects. In particular, they offer special support for compressed representation of elliptic curve elements. Most types in `arkworks-rs` implement these traits."><title>ark_serialize - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ark_serialize" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"><script async defer src="https://apisa.parity.io/latest.js"></script><noscript><img src="https://apisa.parity.io/latest.js" alt="" referrerpolicy="no-referrer-when-downgrade" /></noscript></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../ark_serialize/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../ark_serialize/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate ark_serialize</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">ark_serialize</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/ark_serialize/lib.rs.html#1-486">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h1 align="center">ark-serialize</h1>
<p align="center">
    <img src="https://github.com/arkworks-rs/algebra/workflows/CI/badge.svg?branch=master">
    <a href="https://github.com/arkworks-rs/algebra/blob/master/LICENSE-APACHE"><img src="https://img.shields.io/badge/license-APACHE-blue.svg"></a>
    <a href="https://github.com/arkworks-rs/algebra/blob/master/LICENSE-MIT"><img src="https://img.shields.io/badge/license-MIT-blue.svg"></a>
    <a href="https://deps.rs/repo/github/arkworks-rs/algebra"><img src="https://deps.rs/repo/github/arkworks-rs/algebra/status.svg"></a>
</p>
<p><code>ark-serialize</code> defines the <code>CanonicalSerialize</code> and <code>CanonicalDeserialize</code> traits for serializing and deserializing Rust data structures to bytes efficiently. The interfaces offered by these traits are specialized for serializing cryptographic objects. In particular, they offer special support for compressed representation of elliptic curve elements.
Most types in <code>arkworks-rs</code> implement these traits.</p>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p>To use <code>ark-serialize</code>, add the following to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>ark_serialize = &quot;0.4&quot;
</code></pre></div>
<p>If you additionally want to derive implementations of the <code>CanonicalSerialize</code> and <code>CanonicalDeserialize</code> traits for your own types, you can enable the <code>derive</code> feature:</p>
<div class="example-wrap"><pre class="language-toml"><code>ark_serialize = { version = &quot;0.4&quot;, features = [&quot;derive&quot;] }
</code></pre></div><h4 id="examples"><a href="#examples">Examples</a></h4>
<p>Let us first see how to use <code>ark-serialize</code> for existing types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// We&#39;ll use the BLS12-381 pairing-friendly group for this example.
</span><span class="kw">use </span>ark_test_curves::bls12_381::{G1Projective <span class="kw">as </span>G1, G2Projective <span class="kw">as </span>G2, G1Affine, G2Affine};
<span class="kw">use </span>ark_serialize::{CanonicalSerialize, CanonicalDeserialize};
<span class="kw">use </span>ark_std::UniformRand;

<span class="kw">let </span><span class="kw-2">mut </span>rng = ark_std::test_rng();
<span class="comment">// Let&#39;s sample uniformly random group elements:
</span><span class="kw">let </span>a: G1Affine = G1::rand(<span class="kw-2">&amp;mut </span>rng).into();
<span class="kw">let </span>b: G2Affine = G2::rand(<span class="kw-2">&amp;mut </span>rng).into();

<span class="comment">// We can serialize with compression...
</span><span class="kw">let </span><span class="kw-2">mut </span>compressed_bytes = Vec::new();
a.serialize_compressed(<span class="kw-2">&amp;mut </span>compressed_bytes).unwrap();
<span class="comment">// ...and without:
</span><span class="kw">let </span><span class="kw-2">mut </span>uncompressed_bytes = Vec::new();
a.serialize_uncompressed(<span class="kw-2">&amp;mut </span>uncompressed_bytes).unwrap();

<span class="comment">// We can reconstruct our points from the compressed serialization...
</span><span class="kw">let </span>a_compressed = G1Affine::deserialize_compressed(<span class="kw-2">&amp;*</span>compressed_bytes).unwrap();

<span class="comment">// ... and from the uncompressed one:
</span><span class="kw">let </span>a_uncompressed = G1Affine::deserialize_uncompressed(<span class="kw-2">&amp;*</span>uncompressed_bytes).unwrap();

<span class="macro">assert_eq!</span>(a_compressed, a);
<span class="macro">assert_eq!</span>(a_uncompressed, a);

<span class="comment">// If we trust the origin of the serialization
// (eg: if the serialization was stored on authenticated storage),
// then we can skip some validation checks, which can greatly reduce deserialization time.
</span><span class="kw">let </span>a_uncompressed_unchecked = G1Affine::deserialize_uncompressed_unchecked(<span class="kw-2">&amp;*</span>uncompressed_bytes).unwrap();
<span class="kw">let </span>a_compressed_unchecked = G1Affine::deserialize_compressed_unchecked(<span class="kw-2">&amp;*</span>compressed_bytes).unwrap();
<span class="macro">assert_eq!</span>(a_uncompressed_unchecked, a);
<span class="macro">assert_eq!</span>(a_compressed_unchecked, a);</code></pre></div>
<p>If we want to serialize our own structs, we can derive implementations of the <code>CanonicalSerialize</code> and <code>CanonicalDeserialize</code> traits if all fields implement these traits. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ark_test_curves::bls12_381::{G1Affine, G2Affine};
<span class="kw">use </span>ark_serialize::{CanonicalSerialize, CanonicalDeserialize};

<span class="attr">#[derive(CanonicalSerialize, CanonicalDeserialize)]
</span><span class="kw">pub struct </span>MyStruct {
    a: G1Affine,
    b: G2Affine,
}</code></pre></div>
<p>We can also implement these traits manually. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ark_test_curves::bls12_381::{G1Affine, G2Affine};
<span class="kw">use </span>ark_serialize::{CanonicalSerialize, CanonicalDeserialize, Compress, SerializationError, Valid, Validate};
<span class="kw">use </span>ark_std::io::{Read, Write};

<span class="kw">pub struct </span>MyStruct {
    a: G1Affine,
    b: G2Affine,
}

<span class="kw">impl </span>CanonicalSerialize <span class="kw">for </span>MyStruct {
    <span class="comment">// We only have to implement the `serialize_with_mode` method; the other methods 
    // have default implementations that call the latter.
    //
    // Notice that `serialize_with_mode` takes `mode: Compress` as an argument. This 
    // is used to indicate whether we want to serialize with or without compression.
    </span><span class="kw">fn </span>serialize_with_mode&lt;W: Write&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="kw-2">mut </span>writer: W, mode: Compress) -&gt; <span class="prelude-ty">Result</span>&lt;(), SerializationError&gt; {
        <span class="self">self</span>.a.serialize_with_mode(<span class="kw-2">&amp;mut </span>writer, mode)<span class="question-mark">?</span>;
        <span class="self">self</span>.b.serialize_with_mode(<span class="kw-2">&amp;mut </span>writer, mode)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">fn </span>serialized_size(<span class="kw-2">&amp;</span><span class="self">self</span>, mode: Compress) -&gt; usize {
        <span class="self">self</span>.a.serialized_size(mode) + <span class="self">self</span>.b.serialized_size(mode)
    }
}

<span class="kw">impl </span>CanonicalDeserialize <span class="kw">for </span>MyStruct {
    <span class="comment">// We only have to implement the `deserialize_with_mode` method; the other methods 
    // have default implementations that call the latter.
    </span><span class="kw">fn </span>deserialize_with_mode&lt;R: Read&gt;(<span class="kw-2">mut </span>reader: R, compress: Compress, validate: Validate) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, SerializationError&gt; {
        <span class="kw">let </span>a = G1Affine::deserialize_with_mode(<span class="kw-2">&amp;mut </span>reader, compress, validate)<span class="question-mark">?</span>;
        <span class="kw">let </span>b = G2Affine::deserialize_with_mode(<span class="kw-2">&amp;mut </span>reader, compress, validate)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ a, b })
    }
}

<span class="comment">// We additionally have to implement the `Valid` trait for our struct.
// This trait specifies how to perform certain validation checks on deserialized types.
// For example, we can check that the deserialized group elements are in the prime-order subgroup.
</span><span class="kw">impl </span>Valid <span class="kw">for </span>MyStruct {
    <span class="kw">fn </span>check(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), SerializationError&gt; {
        <span class="self">self</span>.a.check()<span class="question-mark">?</span>;
        <span class="self">self</span>.b.check()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(())
    }
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.EmptyFlags.html" title="struct ark_serialize::EmptyFlags">EmptyFlags</a></div><div class="desc docblock-short">Flags to be encoded into the serialization.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Compress.html" title="enum ark_serialize::Compress">Compress</a></div><div class="desc docblock-short">Whether to use a compressed version of the serialization algorithm. Specific behavior depends
on implementation. If no compressed version exists (e.g. on <code>Fp</code>), mode is ignored.</div></li><li><div class="item-name"><a class="enum" href="enum.SerializationError.html" title="enum ark_serialize::SerializationError">SerializationError</a></div><div class="desc docblock-short">This is an error that could occur during serialization</div></li><li><div class="item-name"><a class="enum" href="enum.Validate.html" title="enum ark_serialize::Validate">Validate</a></div><div class="desc docblock-short">Whether to validate the element after deserializing it. Specific behavior depends on
implementation. If no validation algorithm exists (e.g. on <code>Fp</code>), mode is ignored.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.CanonicalDeserialize.html" title="trait ark_serialize::CanonicalDeserialize">CanonicalDeserialize</a></div><div class="desc docblock-short">Deserializer in little endian format.
This trait can be derived if all fields of a struct implement
<code>CanonicalDeserialize</code> and the <code>derive</code> feature is enabled.</div></li><li><div class="item-name"><a class="trait" href="trait.CanonicalDeserializeWithFlags.html" title="trait ark_serialize::CanonicalDeserializeWithFlags">CanonicalDeserializeWithFlags</a></div><div class="desc docblock-short">Deserializer in little endian format allowing flags to be encoded.</div></li><li><div class="item-name"><a class="trait" href="trait.CanonicalSerialize.html" title="trait ark_serialize::CanonicalSerialize">CanonicalSerialize</a></div><div class="desc docblock-short">Serializer in little endian format.
This trait can be derived if all fields of a struct implement
<code>CanonicalSerialize</code> and the <code>derive</code> feature is enabled.</div></li><li><div class="item-name"><a class="trait" href="trait.CanonicalSerializeHashExt.html" title="trait ark_serialize::CanonicalSerializeHashExt">CanonicalSerializeHashExt</a></div><div class="desc docblock-short">The CanonicalSerialize induces a natural way to hash the
corresponding value, of which this is the convenience trait.</div></li><li><div class="item-name"><a class="trait" href="trait.CanonicalSerializeWithFlags.html" title="trait ark_serialize::CanonicalSerializeWithFlags">CanonicalSerializeWithFlags</a></div><div class="desc docblock-short">Serializer in little endian format allowing to encode flags.</div></li><li><div class="item-name"><a class="trait" href="trait.Flags.html" title="trait ark_serialize::Flags">Flags</a></div><div class="desc docblock-short">Represents metadata to be appended to an object’s serialization. For
example, when serializing elliptic curve points, one can
use a <code>Flag</code> to represent whether the serialization is the point
at infinity, or whether the <code>y</code> coordinate is positive or not.
These bits will be appended to the end of the point’s serialization,
or included in a new byte, depending on space available.</div></li><li><div class="item-name"><a class="trait" href="trait.Read.html" title="trait ark_serialize::Read">Read</a></div><div class="desc docblock-short">The <code>Read</code> trait allows for reading bytes from a source.</div></li><li><div class="item-name"><a class="trait" href="trait.Valid.html" title="trait ark_serialize::Valid">Valid</a></div></li><li><div class="item-name"><a class="trait" href="trait.Write.html" title="trait ark_serialize::Write">Write</a></div><div class="desc docblock-short">A trait for objects which are byte-oriented sinks.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.buffer_bit_byte_size.html" title="fn ark_serialize::buffer_bit_byte_size">buffer_bit_byte_size</a></div></li><li><div class="item-name"><a class="fn" href="fn.buffer_byte_size.html" title="fn ark_serialize::buffer_byte_size">buffer_byte_size</a></div><div class="desc docblock-short">Converts the number of bits required to represent a number
into the number of bytes required to represent it.</div></li></ul></section></div></main></body></html>